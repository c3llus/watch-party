name: Manual Deployment (Blue-Green)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'development'
        type: choice
        options:
        - production
      image_tag:
        description: 'Docker image tag to deploy (e.g., abc1234 or latest)'
        required: false
        default: 'latest'
      force_rebuild:
        description: 'Force rebuild Docker images'
        required: false
        default: false
        type: boolean

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: asia-southeast1

jobs:
  manual_deploy:
    name: Manual Deploy to ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Determine image tags
        id: image_tags
        run: |
          PROJECT_ID=$(echo "${{ secrets.GCP_PROJECT_ID }}" | tr -d '[:space:]')
          DOCKER_REPO="${{ env.GCP_REGION }}-docker.pkg.dev/${PROJECT_ID}/app-services"
          
          if [ "${{ github.event.inputs.image_tag }}" = "latest" ]; then
            TAG=$(echo ${{ github.sha }} | cut -c1-7)
          else
            TAG="${{ github.event.inputs.image_tag }}"
          fi
          
          API_TAG="${DOCKER_REPO}/service-api:${TAG}"
          SYNC_TAG="${DOCKER_REPO}/service-sync:${TAG}"
          
          echo "api_image_tag=${API_TAG}" >> $GITHUB_OUTPUT
          echo "sync_image_tag=${SYNC_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${TAG}" >> $GITHUB_OUTPUT
          
          echo "API Image: ${API_TAG}"
          echo "Sync Image: ${SYNC_TAG}"

      - name: Build and push images (if needed)
        if: github.event.inputs.force_rebuild == 'true' || github.event.inputs.image_tag == 'latest'
        run: |
          echo "Building and pushing Docker images..."
          
          cd backend
          docker build -f service-api/Dockerfile -t ${{ steps.image_tags.outputs.api_image_tag }} .
          docker push ${{ steps.image_tags.outputs.api_image_tag }}
          
          docker build -f service-sync/Dockerfile -t ${{ steps.image_tags.outputs.sync_image_tag }} .
          docker push ${{ steps.image_tags.outputs.sync_image_tag }}

      - name: Check if images exist (if not rebuilding)
        if: github.event.inputs.force_rebuild != 'true' && github.event.inputs.image_tag != 'latest'
        run: |
          echo "Checking if specified images exist..."
          
          if ! gcloud container images describe ${{ steps.image_tags.outputs.api_image_tag }} >/dev/null 2>&1; then
            echo "API image not found: ${{ steps.image_tags.outputs.api_image_tag }}"
            exit 1
          fi
          
          if ! gcloud container images describe ${{ steps.image_tags.outputs.sync_image_tag }} >/dev/null 2>&1; then
            echo "Sync image not found: ${{ steps.image_tags.outputs.sync_image_tag }}"
            exit 1
          fi
          
          echo "All specified images exist"

      # Deploy service-api to Cloud Run
      - name: Deploy API Service to Cloud Run
        run: |
          echo "Deploying service-api to Cloud Run..."
          
          gcloud run deploy service-api \
            --image ${{ steps.image_tags.outputs.api_image_tag }} \
            --region ${{ env.GCP_REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --port 8080 \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 10 \
            --concurrency 80 \
            --timeout 3600 \
            --service-account cloud-run-services@${{ env.GCP_PROJECT_ID }}.iam.gserviceaccount.com \
            --set-env-vars="ENVIRONMENT=production" \
            --quiet

      # Install Ansible
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      # Configure Ansible inventory dynamically
      - name: Configure Ansible for Manual Deployment
        run: |
          cd infrastructure/ansible
          
          INSTANCE_NAME=$(gcloud compute instances list --filter="name~service-sync" --format="value(name)" | head -1)
          ZONE=$(gcloud compute instances list --filter="name~service-sync" --format="value(zone)" | head -1 | sed 's|.*/||')
          
          if [ -z "$INSTANCE_NAME" ]; then
            echo "No service-sync VM found. Please run infrastructure deployment first."
            exit 1
          fi
          
          echo "Found VM: $INSTANCE_NAME in zone: $ZONE"
          
          # create dynamic inventory
          cat > inventory/manual.yml << EOF
          ---
          all:
            children:
              websocket_servers:
                hosts:
                  ${INSTANCE_NAME}:
                    ansible_host: ${INSTANCE_NAME}
                    ansible_user: marcellus
                    gcp_zone: ${ZONE}
                vars:
                  environment: ${{ github.event.inputs.environment }}
                  docker_registry: ${{ env.GCP_REGION }}-docker.pkg.dev
                  project_id: ${{ env.GCP_PROJECT_ID }}
                  app_name: watch-party-sync
                  sync_image_tag: ${{ steps.image_tags.outputs.sync_image_tag }}
          EOF
          
          # configure Ansible to use gcloud compute ssh
          cat > ansible.cfg << EOF
          [defaults]
          host_key_checking = False
          inventory = inventory/
          remote_user = marcellus
          timeout = 30
          gathering = smart
          stdout_callback = yaml
          stderr_callback = yaml
          
          [inventory]
          enable_plugins = yaml
          
          [ssh_connection]
          ssh_executable = gcloud
          ssh_args = compute ssh --zone=%(gcp_zone)s
          ssh_common_args = --ssh-flag="-o UserKnownHostsFile=/dev/null" --ssh-flag="-o StrictHostKeyChecking=no"
          pipelining = True
          EOF

      # Run Ansible setup (if needed)
      - name: Run Ansible Setup (if needed)
        run: |
          cd infrastructure/ansible
          
          INSTANCE_NAME=$(gcloud compute instances list --filter="name~service-sync" --format="value(name)" | head -1)
          ZONE=$(gcloud compute instances list --filter="name~service-sync" --format="value(zone)" | head -1 | sed 's|.*/||')
          
          if ! gcloud compute ssh marcellus@${INSTANCE_NAME} --zone=${ZONE} --command="which docker" >/dev/null 2>&1; then
            echo "Running initial setup - installing packages..."
            ansible-playbook -i inventory/manual.yml playbooks/setup.yml -v
          else
            echo "Setup already completed - Docker found on VM"
          fi

      # Blue-Green Deployment
      - name: Run Blue-Green Deployment
        run: |
          cd infrastructure/ansible
          echo "Starting blue-green deployment to ${{ github.event.inputs.environment }}..."
          ansible-playbook -i inventory/manual.yml playbooks/deploy.yml -v

      # Verify Deployment
      - name: Verify Deployment Health
        run: |
          cd infrastructure/ansible
          ansible-playbook -i inventory/manual.yml playbooks/verify.yml -v || {
            echo "Deployment verification failed - initiating rollback..."
            ansible-playbook -i inventory/manual.yml playbooks/rollback.yml -v
            exit 1
          }

      # Get final status
      - name: Get Deployment URLs
        id: deployment_urls
        run: |
          API_URL=$(gcloud run services describe service-api --region=${{ env.GCP_REGION }} --format="value(status.url)")
          
          INSTANCE_NAME=$(gcloud compute instances list --filter="name~service-sync" --format="value(name)" | head -1)
          WS_IP=$(gcloud compute instances describe $INSTANCE_NAME --zone=$(gcloud compute instances list --filter="name~service-sync" --format="value(zone)" | head -1 | sed 's|.*/||') --format="value(networkInterfaces[0].accessConfigs[0].natIP)")
          
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "websocket_ip=${WS_IP}" >> $GITHUB_OUTPUT

      # Final validation
      - name: Final Health Check
        run: |
          echo "Performing final health checks..."
          
          API_URL="${{ steps.deployment_urls.outputs.api_url }}"
          for i in {1..10}; do
            if curl -f -s "${API_URL}/health" > /dev/null 2>&1; then
              echo "API service is healthy!"
              break
            else
              echo "Waiting for API service... (attempt $i/10)"
              sleep 10
            fi
          done
          
          WS_IP="${{ steps.deployment_urls.outputs.websocket_ip }}"
          for i in {1..10}; do
            if curl -f -s "http://${WS_IP}/health" > /dev/null 2>&1; then
              echo "WebSocket service is healthy!"
              break
            else
              echo "Waiting for WebSocket service... (attempt $i/10)"
              sleep 10
            fi
          done
